import { MarketTrend, ProjectTask } from "../types";

export const generateMarkdownReport = (
  trend: MarketTrend,
  vision: { vision: string; kpis: string[] },
  tasks: ProjectTask[]
): string => {
  const date = new Date().toLocaleDateString('th-TH');
  
  let md = `# ${trend.trend}\n\n`;
  md += `> **Project Name:** ${trend.projectName}\n`;
  md += `> **Generated by:** à¸à¸­à¸‡à¸—à¸±à¸ž à¹€à¸­à¹„à¸­ à¸‹à¸­à¸Ÿà¹à¸§à¸£à¹Œ (AI Software Army)\n`;
  md += `> **Date:** ${date}\n\n`;

  md += `## 1. Market Intelligence (à¸‚à¹ˆà¸²à¸§à¸à¸£à¸­à¸‡à¸•à¸¥à¸²à¸”)\n`;
  md += `- **Sector:** ${trend.sector}\n`;
  md += `- **Opportunity:** ${trend.opportunity}\n\n`;

  md += `## 2. Executive Strategy (à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¸œà¸¹à¹‰à¸šà¸£à¸´à¸«à¸²à¸£)\n`;
  md += `### Vision (à¸§à¸´à¸ªà¸±à¸¢à¸—à¸±à¸¨à¸™à¹Œ)\n${vision.vision}\n\n`;
  md += `### KPIs (à¸”à¸±à¸Šà¸™à¸µà¸Šà¸µà¹‰à¸§à¸±à¸”)\n`;
  vision.kpis.forEach(kpi => md += `- ${kpi}\n`);
  md += `\n`;

  md += `## 3. Operational Plan (à¹à¸œà¸™à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸à¸²à¸£)\n`;
  md += `| Task ID | Task Name | Agent | Status |\n`;
  md += `|---|---|---|---|\n`;
  tasks.forEach(t => {
    md += `| ${t.id.split('-').pop()} | ${t.title} | ${t.assignedAgentId} | ${t.status} |\n`;
  });
  md += `\n`;

  md += `## 4. Execution Outputs (à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œà¸à¸²à¸£à¸—à¸³à¸‡à¸²à¸™)\n`;
  md += `Here are the artifacts produced by the AI Software Army agent swarm.\n\n`;
  
  tasks.forEach(t => {
    if (t.output) {
      md += `### ðŸŸ¢ [${t.assignedAgentId}] ${t.title}\n`;
      md += `**Agent:** ${t.assignedAgentId}\n\n`;
      md += "```\n" + t.output + "\n```\n\n";
      md += "---\n\n";
    }
  });

  return md;
};

export const createGitHubRepo = async (token: string, name: string, description: string) => {
  // 1. Create Repo
  const createRes = await fetch('https://api.github.com/user/repos', {
    method: 'POST',
    headers: {
      'Authorization': `token ${token}`,
      'Content-Type': 'application/json',
      'Accept': 'application/vnd.github.v3+json'
    },
    body: JSON.stringify({
      name,
      description,
      private: false, // Public repo
      auto_init: true // Create with README initially
    })
  });

  if (!createRes.ok) {
    const err = await createRes.json();
    throw new Error(err.message || 'Failed to create repo');
  }

  const repoData = await createRes.json();
  return repoData;
};

export const updateRepoReadme = async (
  token: string, 
  owner: string, 
  repo: string, 
  content: string
) => {
  const path = "README.md";
  
  // 1. Get SHA of existing README (created by auto_init)
  let sha = undefined;
  try {
    const getRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
       headers: { 'Authorization': `token ${token}` }
    });
    if (getRes.ok) {
       const fileData = await getRes.json();
       sha = fileData.sha;
    }
  } catch (e) { /* ignore */ }

  // 2. Update Content
  // Note: Using btoa with encodeURIComponent to handle UTF-8/Thai characters properly
  const base64Content = btoa(unescape(encodeURIComponent(content)));

  const updateRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
    method: 'PUT',
    headers: {
      'Authorization': `token ${token}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      message: 'AI Software Army: Automatic Report Update',
      content: base64Content,
      sha
    })
  });

  if (!updateRes.ok) {
    throw new Error('Failed to upload report');
  }
  
  return updateRes.json();
};